{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Jose Pepe Space","text":"<p>Hi there! Jose Pepe here.</p> <p>I am a software developer specialized in Backend with experience in agile methodologies and handling most of the software lifecycle.  Thank you for your visit, and I will guide you on what you can find in this space:</p> <ul> <li>For CV, go here</li> <li>Learning Updates</li> <li>Open-Source contribution updates</li> <li>Entries and blogging</li> </ul>"},{"location":"blog/","title":"Software Development with JP","text":""},{"location":"blog/#articles-on-software-development","title":"Articles on Software Development","text":""},{"location":"blog/#ai-generated-package-attack-vector-how-to-prevent-and-mitigate-it","title":"\ud83d\udce6 AI-Generated Package Attack vector: How to prevent and mitigate it?","text":"<p>In the era of AI-assisted development, integrating packages recommended by large language models (LLMs) is becoming routine. But what happens when these models suggest libraries that don\u2019t exist\u2014or worse, resolve to malicious ones? As software developers and commercial software agents, we're navigating a space where speed and innovation must be balanced with security and reliability.</p> <p>This article explores a potential mitigation strategy for hallucinated or suspicious packages entering your codebase through AI-assisted coding. It outlines current NPM security measures, proposes a developer-centered auditing workflow, and evaluates the impact on both CI/CD pipelines and delivery speed.</p> <p>Whether you're building critical infrastructure or managing compliance in your dev lifecycle, this piece offers a thoughtful starting point for tackling this emerging threat with practical, developer-friendly measures.</p> <p>What if your AI assistant gave you bad advice and your pipeline installed it without question?</p> <p>Read it now! to learn how to keep human judgment at the center of your automated workflows.</p>"},{"location":"blog/#open-source-contributions","title":"Open Source Contributions","text":"<p>This is under construction, in the coming weeks here will be:</p> <ul> <li>Updates on contributions to open source projects</li> </ul>"},{"location":"cv/","title":"Desarrollador Backend JS | Jose Simon Pepe","text":""},{"location":"cv/#resumen","title":"Resumen","text":"<p>Desarrollador de software con experiencia en metodolog\u00edas \u00e1giles (XP, Extreme Programming), especializado en BackEnd para aplicaciones web y stand-alone. Capacidad para interactuar con stakeholders, analizar requerimientos, dise\u00f1ar arquitecturas, implementar pruebas automatizadas y gestionar despliegues mediante CI/CD.</p>"},{"location":"cv/#experiencia","title":"Experiencia","text":"<p>Desarrollador Backend Freelance (2020 - 2025)</p> <ul> <li>Desarrollo de una aplicaci\u00f3n inmobiliaria.</li> <li>Desarrollo de una red social.</li> <li>Dise\u00f1o y desarrollo de sitios web para una empresa de envases publicitarios y un programa de ense\u00f1anza de ingl\u00e9s.</li> <li>Contribuciones Open Source: GitHub</li> </ul> <p>Tecnolog\u00edas:</p> <ul> <li>Backend: JavaScript, Node.js, Python (FastAPI, Django)</li> <li>DevOps &amp; Cloud: AWS, Cloudflare, Linux Manjaro, Git, GitHub</li> <li>Idiomas: Espa\u00f1ol (nativo), Ingl\u00e9s (lectura/escritura para desarrollo, trabajo en equipo en ingl\u00e9s t\u00e9cnico)</li> </ul> <p>Referencia:</p> <ul> <li>Martin Alga\u00f1araz (Arquitecto de Software) - Tel: +54 9 2236 68-7186</li> </ul>"},{"location":"cv/#contacto","title":"Contacto","text":"<ul> <li>LinkedIn: Perfil</li> <li>Correo: jose.s.contacto@gmail.com</li> <li>Portafolio: GitHub</li> <li>Blog de estudio y trabajo: Sitio Web</li> <li>N\u00famero: +54 9 11 2401-0760</li> <li>Ubicaci\u00f3n: AMBA, BSAS, Argentina.</li> </ul>"},{"location":"cv/#certificaciones","title":"Certificaciones","text":"<ul> <li>T\u00e9cnico en Programaci\u00f3n Web Full Stack - UNAHUR, CeDIT UNLaM, MTESA (18/10/2021 - 02/06/2022)</li> <li>Asuntos Cibern\u00e9ticos con Perspectiva en Ciberseguridad y Ciberdelito - UNLaM (10/08/2022)</li> </ul>"},{"location":"cv/#educacion","title":"Educaci\u00f3n","text":"<ul> <li>Tecnicatura Superior en Desarrollo Web - UNLaM (2020 - 2024)</li> <li>Mentor\u00edas privadas en Arquitectura y Dise\u00f1o de Software - Martin Alga\u00f1araz (Miembro de Equilibrium.io)</li> <li>Aprendizaje continuo en Backend, DevOps y metodolog\u00edas \u00e1giles</li> </ul>"},{"location":"cv/#filosofia-de-trabajo","title":"Filosof\u00eda de Trabajo","text":"<ul> <li>El trabajo en equipo potencia el \u00e9xito de los proyectos.</li> <li>La presencialidad mejora la comunicaci\u00f3n y la colaboraci\u00f3n.</li> <li>El software debe responder a las necesidades del negocio.</li> <li>Desarrollar software combina creatividad y l\u00f3gica.</li> <li>Es fundamental reconocer cuando se desconoce algo y aprenderlo cuando sea necesario.</li> </ul>"},{"location":"cv_en/","title":"Backend Developer JS | Simon Jose Pepe","text":""},{"location":"cv_en/#summary","title":"Summary","text":"<p>Software developer with experience in agile methodologies (XP, Extreme Programming), specialized in Backend development for web and stand-alone applications. Skilled in stakeholder communication, requirement analysis, architecture design, automated testing, and CI/CD deployment management.</p>"},{"location":"cv_en/#experience","title":"Experience","text":"<p>Freelance Backend Developer (2020 - 2025)</p> <ul> <li>Development of a real estate application.</li> <li>Development of a social network.</li> <li>Design and development of websites for a promotional packaging company and an English teaching program.</li> <li>Open Source contributions: GitHub Profile</li> </ul> <p>Technologies:</p> <ul> <li>Backend: JavaScript, Node.js, Python (FastAPI, Django)</li> <li>DevOps &amp; Cloud: AWS, Cloudflare, Linux Manjaro, Git, GitHub</li> <li>Languages: Spanish (native), English (reading/writing for development, teamwork in technical English)</li> </ul> <p>Reference:</p> <ul> <li>Martin Alga\u00f1araz (Software Architect) - Tel: +54 9 2236 68-7186</li> </ul>"},{"location":"cv_en/#contact","title":"Contact","text":"<ul> <li>LinkedIn: LinkedIn Profile</li> <li>Email: jose.s.contacto@gmail.com</li> <li>Portfolio: GitHub Portfolio</li> <li>Study &amp; Work Blog: Personal Blog</li> <li>Phone: +54 9 11 2401-0760</li> <li>Location: AMBA, BSAS, Argentina.</li> </ul>"},{"location":"cv_en/#certifications","title":"Certifications","text":"<ul> <li>Full Stack Web Programming Technician - UNAHUR, CeDIT UNLaM, MTESA (10/18/2021 - 06/02/2022)</li> <li>Cyber Affairs with a Focus on Cybersecurity and Cybercrime - UNLaM (08/10/2022)</li> </ul>"},{"location":"cv_en/#education","title":"Education","text":"<ul> <li>Advanced Technical Degree in Web Development - UNLaM (2020 - 2024)</li> <li>Private Mentorships in Software Architecture and Design - Martin Alga\u00f1araz (Member of Equilibrium.io)</li> <li>Continuous learning in Backend, DevOps, and Agile methodologies</li> </ul>"},{"location":"cv_en/#work-philosophy","title":"Work Philosophy","text":"<ul> <li>Teamwork enhances project success.</li> <li>In-person collaboration improves communication and efficiency.</li> <li>Software should meet business needs.</li> <li>Developing software is a blend of creativity and logic.</li> <li>Acknowledging knowledge gaps and learning when necessary is essential.</li> </ul>"},{"location":"learning_roadmap/","title":"Software Development Learning Roadmap","text":"<p>Como desarrollador de software con experiencia y orientacion al BackEnd, actualmente  estoy ampliando mis conocimientos hacia el desarrollo frontend, especialmente en aplicaciones de una sola p\u00e1gina (SPA). Adem\u00e1s, estoy fortaleciendo mis habilidades en arquitectura de software, incorporando tecnicas y metodologias de DevOps, y comprendiendo el trabajo con tecnolog\u00edas emergentes en la nube y herramientas de inteligencia artificial especialmente self-hosted. </p> <p>Esta es una breve presentacion del plan de estudios que sigo actualmente (2025-02-12):</p>"},{"location":"learning_roadmap/#1-frontend-development","title":"1. Frontend Development","text":"<p>El objetivo aqu\u00ed es dominar las tecnolog\u00edas clave para el desarrollo frontend moderno, desde los fundamentos hasta la creaci\u00f3n de aplicaciones SPA de alta interactividad que soporte web3.</p> <ul> <li>Alpine.js: Uso de esta libreria de js para mejorar la interactividad de sitios web. Me ha permitido hidratar documentos que son enviados desde el servidor, en una metodologia conocida como \"Client Side Rendering\".</li> <li>HTML Templating: T\u00e9cnicas para estructurar contenido din\u00e1mico de manera eficiente. Dado que las templates de HTML tienen un DOM especial, estoy comprendiendo como aumenta la reusabilidad y que posibilidades de creacion de Scaffolding permite.</li> <li>SPA (Single Page Applications): Profundizaci\u00f3n en fundamentos de arquitectura web y frameworks para la creaci\u00f3n de aplicaciones din\u00e1micas. No me estoy atando a la manera de hacer las cosas de un Framework, si no que ahora estoy comprendiendo las bases para luego ver como es que los FW pueden ser utiles.</li> <li>Webpack y browserify: Empaquetado y optimizaci\u00f3n de recursos para mejorar la eficiencia de aplicaciones web y su entrega.</li> <li>CSS Generators y dise\u00f1o din\u00e1mico: Herramientas para la generacion  autom\u00e1tica de estilos.</li> <li>React: Exploraci\u00f3n y pr\u00e1ctica con uno de los frameworks m\u00e1s usados actualmente para la construcci\u00f3n de interfaces interactivas y SPA.</li> </ul>"},{"location":"learning_roadmap/#2-programacion-web","title":"2. Programaci\u00f3n Web","text":"<ul> <li>Principios b\u00e1sicos del desarrollo web. (Mucho de esto lo vi en la Universidad)</li> <li>Funcionamiento de los servidores web y navegadores. (Mucho de esto lo veo gracias a la enorme documentacion publica de estas herramientas, por ej la mantenida por WHATWG)</li> </ul>"},{"location":"learning_roadmap/#3-integracion-de-pagos","title":"3. Integraci\u00f3n de Pagos","text":"<ul> <li>Implementaci\u00f3n de pasarelas de pago y transacciones seguras. No solo usar las API de ML o un boiler en Strapi y tenerlo listo, si no comprender las consideraciones desde la arquitectura para evitar problemas en este area crucial.</li> </ul>"},{"location":"learning_roadmap/#4-deployment-y-hosting","title":"4. Deployment y Hosting","text":"<ul> <li>Scaffolding y boilerplate: Generaci\u00f3n de proyectos con buenas pr\u00e1cticas desde el inicio.</li> <li>Despliegue de aplicaciones en Node.js con Render.</li> <li>Cloudinary: Uso del free tier para optimizar la gesti\u00f3n de im\u00e1genes en la nube.</li> <li>Google Cloud Console: Exploraci\u00f3n de servicios en la nube para despliegues escalables.</li> <li>SSH: Uso en tareas de deployment y administraci\u00f3n de servidores.</li> </ul>"},{"location":"learning_roadmap/#5-backend-development","title":"5. Backend Development","text":"<ul> <li>Python y Node.js: Profundizaci\u00f3n en estos lenguajes para construir APIs eficientes.</li> <li>Strapi: Uso de este CMS headless para gestionar contenido din\u00e1mico.</li> <li>SQLite: Implementaci\u00f3n y optimizaci\u00f3n de bases de datos ligeras.</li> <li>Webhooks: Integraciones entre sistemas mediante eventos en tiempo real.</li> </ul>"},{"location":"learning_roadmap/#6-api-y-autenticacion","title":"6. API y Autenticaci\u00f3n","text":"<ul> <li>OAuth2: Implementaci\u00f3n de protocolos de autenticaci\u00f3n segura.</li> <li>GraphQL: Exploraci\u00f3n de esta tecnolog\u00eda para mejorar la eficiencia de las APIs.</li> </ul>"},{"location":"learning_roadmap/#7-manejo-de-datos-y-bases-de-datos","title":"7. Manejo de Datos y Bases de Datos","text":"<ul> <li>Entity Frameworks y ORM: T\u00e9cnicas de abstracci\u00f3n para el manejo eficiente de bases de datos.</li> <li>Estructuras de datos y algoritmos: Mejora de la eficiencia en la manipulaci\u00f3n de datos.</li> <li>An\u00e1lisis de comportamiento de usuarios en sitios web.</li> <li>Gesti\u00f3n eficiente de bases de datos como desarrollador.</li> </ul>"},{"location":"learning_roadmap/#8-arquitectura-de-software-y-herramientas","title":"8. Arquitectura de Software y Herramientas","text":"<ul> <li>Patrones de arquitectura: Buenas pr\u00e1cticas para el dise\u00f1o de sistemas escalables.</li> <li>Agentes de IA y automatizaci\u00f3n con n8n.</li> <li>SupaBase: Alternativa a Firebase para la gesti\u00f3n de bases de datos en tiempo real.</li> <li>NPM y su ecosistema.</li> <li>Pipeline architecture: Implementaci\u00f3n de procesos de integraci\u00f3n y despliegue continuo.</li> <li>Huly: Exploraci\u00f3n de nuevas herramientas para mejorar la comunicacion con los interesados y equipo.</li> </ul>"},{"location":"learning_roadmap/#9-diseno-y-redes","title":"9. Dise\u00f1o y Redes","text":"<ul> <li>Brokers y Gateways: Conceptos fundamentales para la comunicaci\u00f3n entre servicios.</li> <li>Proxy y Proxy Inverso: Mejora del rendimiento y seguridad en arquitecturas web.</li> <li>CDN y DNS: Optimizaci\u00f3n de la distribuci\u00f3n de contenido.</li> <li>Dise\u00f1o de sistemas y diagramas de flujo. Principalmente usado con clientes freelance.</li> <li>P2P vs Vendor Locking: Evaluaci\u00f3n de estrategias para evitar la dependencia de proveedores.</li> <li>IDL y esquematizaci\u00f3n de interfaces.</li> </ul>"},{"location":"learning_roadmap/#10-devops-y-herramientas-de-infraestructura","title":"10. DevOps y Herramientas de Infraestructura","text":"<ul> <li>Terraform: Infraestructura como c\u00f3digo para gestionar recursos en la nube y gestionar vendor-lockin.</li> <li>Kubernetes (k8s): Orquestaci\u00f3n de contenedores para despliegues escalables. Principalmente entender como usarlos para tareas de desarrollo.</li> <li>GitLab CI y GitHub Actions: Automatizaci\u00f3n de procesos de integraci\u00f3n y entrega continua. Principalmente he usado Github Actions.</li> <li>Grafana: Monitoreo y an\u00e1lisis de m\u00e9tricas en tiempo real.</li> </ul> <p>Esto es hasta hoy dia mi plan de estudios. Si queres conocer aplicaciones de estos conocimientos, podes visitar mi seccion de 'soluciones creadas' en mi perfil de github</p>"},{"location":"blog/slopsquatting-vulnerabilities-preventor/","title":"Slopsquatting, how the speed of AI-based development exploits an old attack vector, and how we could prevent it.","text":""},{"location":"blog/slopsquatting-vulnerabilities-preventor/#goal","title":"Goal","text":"<p>To propose and implement a tool usable by developers during artificial intelligence-assisted programming to prevent slopsquatting vulnerabilities.</p>"},{"location":"blog/slopsquatting-vulnerabilities-preventor/#sources-and-notes","title":"Sources and Notes","text":"<p>Here we're diving into a well known AI trouble: model hallucination and how it's affecting the AI-assisted software development. For this purpose, I'll be supporting this article in a research paper published on March 2, 2025 by USENIX entitled \"We Have a Package for You! A Comprehensive Analysis of Package Hallucinations by Code Generating LLMs\"</p> <p>On \"Slopsquatting\" term: this is a pretty new and colloquial term invented by the low-code development community, there is no \"slopsquatting\" references into Usenix's study. This article is my own elaboration, as Jose Pepe I have no relationship with Usenix and I am just a user of some of the tools I mention here.</p>"},{"location":"blog/slopsquatting-vulnerabilities-preventor/#how-to-read","title":"How to read","text":"<p>The objective of this proposal is to understand how to use AI for software development in high-speed delivery cycles while mitigating one of its most important risks. You won't know if this tool is useful to you until you understand the problem we face as AI-assisted developers, so the order of reading will be as follows: first (1) I will explain and evaluate the problem based on the study published on March 2, 2025 by USENIX entitled \"We Have a Package for You! A Comprehensive Analysis of Package Hallucinations by Code Generating LLMs\", and then (2) I will present and explain the tool I developed as a potential preventive aid.</p>"},{"location":"blog/slopsquatting-vulnerabilities-preventor/#1-the-problem","title":"1. The problem","text":""},{"location":"blog/slopsquatting-vulnerabilities-preventor/#why-does-it-affect-you-as-a-developer-or-businessman","title":"Why does it affect you as a developer or businessman?","text":"<p>Attention and prevention of \"slopsquatting\" is a main concern for the use of LLMs in programming tasks because almost one fifth of the generated packets are hallucinations and probable attack vectors. Consider that: about 97% of programmers use AI for programming tasks today, and approximately 30% of the code that is written every day is Artificial Intelligence-generated.</p> <p>Due to the high speed of delivery demanded in certain market areas, AI tools are increasingly relied upon to generate code. If the risks are not known then the damage it can cause is incalculable: for a developer it can mean being responsible for having generated a backdoor into the organization where he's working, and for a company it can mean the breach of their systems and loss of trust by the market. Trust without understanding can even mean that the speed of development plummets due to more time and personnel dedicated to auditing and maintaining AI-generated code.</p> <p>One of these issues called \"model hallucination\" derivates in a security threat that has been named \"Slopsquatting\" by some forums of the online dev-community and technology company newsrooms, and is affecting one in five packets written in code generated by open-source LLM. Using Usenix's study words: \"at least 5.2% for commercial models and 21.7% for open-source models\".</p>"},{"location":"blog/slopsquatting-vulnerabilities-preventor/#how-it-works","title":"How it works?","text":"<p>In simple terms, slopsquatting consist on the LLM generating a code using a named external package, and this external package in reality either does not exist or is fraudulent, so the incorporation of the obtained code will generate either a broken installation of the working project, or the installation of malicious code in the development environment and potentially in the project's file repository.</p> <p>The problem is observed when instructing an LLM to perform a programming task that is likely to require the use of an external module (like a project dependency), and especially when using a language whose package management is done through a centralized repository. For this article we take the case of Javascript and its package manager NPM.</p> <p>In which LLMs does this happen? The percentage of package hallucination is lower in commercial extended language models, while it is higher in open source ones.</p> <p>In which kind of packages does this happen? Slopsquatting requires that an LLM be widely used by communities of developers (ie ChatGPT) and also that the package name to be used is a common result of the hallucination of that LLM in particular.</p> <p>Slopsquatting is an infection technique within the \u201cpacket confusion attacks\u201d that consists of distributing malicious code using package names resulting from the hallucination of an LLM. It should be clarified that by confusion I'm not only referring to confusion on the part of the programmer; while the programmer may be confused, a malicious actor will directly attempt to confuse the package manager's dependency conflict resolver, and may not only succeed in installing the malicious package based on human confusion, but by forcing it.</p> <p>It should also be noted that the injection of this type of package can occur anywhere in the dependency tree, it is a difficult problem to control, and for a developer it can be impossible depending on the project he is working on.</p>"},{"location":"blog/slopsquatting-vulnerabilities-preventor/#how-does-it-look-from-the-attackers-point-of-view","title":"How does it look from the attacker's point of view?","text":"<p>The source article concludes that packet hallucination is a repeatable result. This means that an attacker can rely on the probability of repetition of a number of hallucinated packet names as an entry point to an attack.</p> <p>In addition, for each LLM there is a likely set of hallucinated package names, while it is unlikely that two or more LLMs will match on a hallucination of package names.</p> <p>Also, it is more likely that packet hallucination will generate packet names more different from those that exist (instead of using a name like \u201cgoolge\u201d to brand-hack a google package, they would use a rather different word.) so an attacker should look for repeatability within an LLM to obtain a likely attack vector rather than trying typos.</p> <p>It is intuitive to think that an attacker would try to get, for each massively used LLM, the set of names of hallucinated packages, and then start publishing using multiple accesses to centralized repositories (such as npm) packages with code that could, for example if it is a networked device, query DNS to a domain under its control, whose requests may leak basic information such as the computer name, the path in the file system....</p>"},{"location":"blog/slopsquatting-vulnerabilities-preventor/#llms-and-hallucinations","title":"LLMs and hallucinations","text":"<p>What is a hallucination and why is it caused? In terms of LLMs, hallucination consists of returning a result that does not correspond to the instruction given by the user of the model. The hallucination can be due to problems with the training data, problems with the training procedures, or problems during inference. The hallucination that gives rise to Slopsquatting is the \"package hallucination\", which is a type of \"fact hallucination\".</p> <p>Hallucination during inference is related to verbosity and model temperature, both of which make the model more prone to hallucination.</p> <p>Hallucination is a type of behavior of an LLM in the inference phase that also involves other associated behaviors, e.g. a certain amount of verbosity, certain grammar, etc.</p> <p>About the study that supports this article, as well as the other cited studies on AI applied to software development are done using datasets of development tasks including public and massive sources such as stack overflow.</p>"},{"location":"blog/slopsquatting-vulnerabilities-preventor/#which-cant-be-done-as-a-diagnosis","title":"Which can't be done as a diagnosis?","text":"<p>The comparison between known package names and the names generated by an LLM is not a solution, because a malicious user may have published a malicious package before this comparison is made. An attacker can even pretend that his malicious package is being downloaded and incorporated into the dependency chain of the node repository Filtering the LLM output based on reserved import words in languages (such as require) is not useful for getting malicious module injections because, from the filtering, we will get packages and not modules which are the ones containing the payload of the attack.</p>"},{"location":"blog/slopsquatting-vulnerabilities-preventor/#which-can-be-done-as-prevention","title":"Which can be done as prevention?","text":"<p>As a Client after prompting, we will first need to know the current state of the LLMs we use as tools for programming.  For example, we will need to know data such as Codellama 7B is the model most prone to packet hallucinations, and javascript is more prone to packet hallucination than python. Also that a model is highly likely to detect its own packet hallucinations and self-correct, even if we do not ask it to do so. It is a good idea to ask for the resolution of a problem in code and then check the central repository database, and ask the model for a correction if necessary, even asking to use specific packages. A 'curious' thing on Javascript and Python, is that when an llms is given a javascript programming task and it hallucinates, it is likely to return code using a package that does not belong to npm but to python PyPI (mainly) or another language's package manager.</p>"},{"location":"blog/slopsquatting-vulnerabilities-preventor/#2-my-proposal-which-can-be-done-as-mitigation","title":"2. My proposal: Which can be done as mitigation?","text":"<p>There are things that are possible for both an LLM client and a supplier. I'm focusing on the client, as that is my current role in using AI for work.</p> <p>Here in mitigation, as in prevention, is the pre-generation code defense, and post generation.</p> <p>The pre-generation slopsquatting defense, as LLM clients, will focus on the prompt we provide as input; here, the article clarifies that RAG is the client-oriented technique which provides the best results on mitigation. Also points on that Packet hallucination mitigation strategies affect the quality of the code generated by the LLMs.</p> <p>My proposal focuses on post-generation mitigation, as I assume that AI will continue to be used for code generation while LLM providers try to improve hallucination statistics, so we have to find how to maintain productivity while ensuring safety.</p> <p>And, in post generation, my proposal has two steps:</p> <ol> <li>firstly to identify suspicious package traits</li> <li>then to force the programmer to recognize and validate such a package, before it is installed in the development environment and potentially incorporated into the project repository.</li> </ol> <p>There are scripts and hooks that call the packages at the very moment when the installation is finished, that is the risk that I try to avoid with the proposal. Reliability is returned to the programmer in a way that maintains productivity; AI is still used for code generation while its development environment forces the programmer to take responsibility for his product.</p>"},{"location":"blog/slopsquatting-vulnerabilities-preventor/#proposal-explanation-on-node","title":"Proposal Explanation on Node","text":""},{"location":"blog/slopsquatting-vulnerabilities-preventor/#the-mechanisms-by-which-malicious-packages-could-execute-in-a-development-environment","title":"The mechanisms by which malicious packages could execute in a development environment","text":"<p>First let's do a brief overview of how npm works in the contexts of downloading and installing packages, and executing commands.</p> <p>NPM is composed by a centralized repository, whose url is https://registry.npmjs.org/, plus a version control system for dependencies consistency and a CLI client.</p> <p>When working with external packages, cli client will search online that package across several web protocols such as git, http, etc and, once it's found, it gets downloaded and then installed. When working with packages into working directory, then npm will install it directly from the named file or flder. If you don't pass any parameter to \u00b4npm install\u00b4 then it's gonna search in the current working directory for a file called package.json, after read that npm will read the package-lock.json if exists, and then it's will download all required packages (and its dependencies) as tgz packages and finally uncompress all those into node_modules/. node_modules is a directory used as a cache memory shared by the whole package. </p> <p>This is when the phenomenon called \u201cdependency resolution\u201d takes place, which is the automatic identification of each required resource, its provider and its version, in order to achieve a non-corrupt installation for the whole environment where the main package (working project) is going to be executed (and remember that the dependencies of a package have a whole chain of necessary sub-dependencies, it's really a miracle that we still exist, isn't it). There are also nested dependency trees, created by npm to solve the construction of two or more dependencies that use different versions of the same dependency. Once the complete dependency tree of the main package is installed, the npm hoisting algorithm is run, which selects which particular version or package to use at runtime in case a dependency is used in the dependency tree by more than one importer having multiple versions of the same dependency, this is for performance sake.</p>"},{"location":"blog/slopsquatting-vulnerabilities-preventor/#the-current-package-management-security-controls-that-might-already-mitigate-these-risks","title":"The current package management security controls that might already mitigate these risks","text":"<p>Into NPM there already are some security controls:</p> <ol> <li> <p>NPM audit: Npm can detect known dependencies vulnerabilities, but it requires those has been reported before. No completely useful here.</p> </li> <li> <p>Using scopes: If you're using well defined scope-limited packages you can reduce collision risk or generic names.</p> </li> <li> <p>Account verification: Maintainers has to have 2FA for publish packages, and NPM is showing if a package has an actived 2FA or not. </p> </li> </ol> <p>For us, Node Developers, there are some common practices helping to reduce these risks:</p> <ol> <li> <p>Locking specify version of dependencies: If joined with a careful revision of each dependency update into the project (including a node_modules revision), then you can know what dependencies are you using and check their reliability.</p> </li> <li> <p>Dependency Analysis tools (for SCA and other techniques) For CICD, or just a well configured development environment, there are code auditoring tools for detect no reported vulnerabilities, npm has no such mechanism by itself.</p> </li> <li> <p>Blocking unreliable packages in CICD Configurating policies, commonly using npmrc, for ensure packages integrity using some hash mark, check package popularity, ensure that package's repository has active maintenance... and so.</p> </li> </ol>"},{"location":"blog/slopsquatting-vulnerabilities-preventor/#the-proposed-mitigation-solution-just-thinking-on-it","title":"The proposed mitigation solution, just thinking on it!","text":"<p>My proposal, a mitigation proposal for when the hallucinated package is already in the development environment but has not yet been installed, is to define reliability criteria, and force the developer to audit the package that the system determines to be suspicious based on those criteria so that the developer can decide whether or not to install the new suspicious dependencies.</p> <p>This is a banality, but a useful one as it allows to exploit AI and keep the most useful of the human as a developer.</p> <p>An example: If you had a continuous integration and delivery flow with a highly modularized and decoupled system, and you wanted to accelerate the speed of development with an automatic scheduling and integration agent, you could sandbox the module in which this agent works into an environment that emulates the target production environment, use the minimal permissions to access external resources that allow you to deliver to the user a usable iteration from their point of view but constrained from the back end, and send directly the integration of new deliveries to that environment where after running (long enough) it can be freed from that box of constraints to simply serve in production. For this you should set up feature flagging that allows you to also do incremental delivery. Using the tool I proppose, you could be informed by notifications that your code had malicious (or suspicious) packages and since you are in sandbox you could quarantine them or kill the test environment, just to review it later.</p>"},{"location":"blog/slopsquatting-vulnerabilities-preventor/#the-workflow-impact-of-the-proposed-mitigation-solution","title":"The workflow impact of the proposed mitigation solution","text":"<p>The best impact would be greater reliability when using AI assistants for coding, knowing that you won\u2019t need to audit all the code the model provides, as you\u2019ll focus only on what appears suspicious.</p> <p>The worst impact would be dependency conflicts arising from a quarantine system. New packages are generated every day by building on top of previous ones in the centralized NPM repository, so this proposal MUST be implemented retroactively. What should be done about malicious packages that are already part of the dependency chains of the tools we use?</p> <p>Without a deep reflection, I can also mention that adding another step to an integration flow (as I\u2019m proposing) could lengthen release times. I might also think this solution could clash with the promise of trends like vibe-coding due to the constant auditing I\u2019m suggesting.</p>"},{"location":"blog/slopsquatting-vulnerabilities-preventor/#ending-ideas-on-proposal","title":"Ending ideas on proposal","text":"<p>For me, you are only productive using LLM when what you invest in auditing the result is less than what you invest in developing the code without LLM. Today AI is a toolbox that we have to know and sometimes know how to use well. Failure to do so limits our development opportunities and reduces the chances of product success. With patience, attention and the love that we #geeks always have for these things, we move forward steadily.</p> <p>In the tool I'm thinking here, there are several missing points. What about false positives? What to do when you realise about a malicious package? How large should a project be to avoid creating a bottleneck in human validation?</p> <p>I'd love to hear critiques and counterproposals. In the coming days, if this article receives feedback, I'll implement an open-source PoC.</p>"},{"location":"blog/slopsquatting-vulnerabilities-preventor/#contact","title":"Contact","text":"<p>You can send me an email to: jose.s.contacto@gmail.com</p> <p>Also you can send me a WhatsApp to: +54 9 11 2401-0760</p> <p>Link to article: We Have a Package for You! A Comprehensive Analysis of Package Hallucinations by Code Generating LLMs</p>"}]}